## Java 虚拟机
	
运行JVM字节码的工作由解释器来完成 （Java解释器是JVM的一部分）
整个解释过程分为
1. 代码装入  (Class Loader)
2. 代码校验
3. 代码执行
Java字节码的执行方法:解释器每次解释并执行一小段代码来完成Java字节码程序的所有操作

#### JVM
- JVM是一种用于计算设备的规范
- JVM包括一套字节码指令集，一组寄存器，一个栈，一个垃圾回收堆和一个存储方法域
- JVM是可运行Java代码的假象计算机
- JVM存在于内存中，根据不同的CPU翻译成不同的语言

> 运行一个Java程序的同时诞生了一个JVM实例，如果运行三个就会产生三个JVM实例。

###### JVM的作用
- 为实现平台无关性
- 是运行java程序的软件环境(Java解释器就是Java虚拟机的一部分)
- (Java程序通过JVM实现跨平台，JVM本身不跨平台)
> 就像接口似的,只要根据JVM规格描述将解释器移植到特定的计算机上，就能保证编译过的Java代码能够在该系统上运行。
> 启动一个Java程序时同时诞生一个虚拟机实例，如果运行是那个Java程序，会得到三个Java虚拟机实例。

######Java指令集(相当于Java程序的汇编语言)
 JVM支持大约248个字节码，每个字节码执行一种基本的CPU运算。
```
do{
	取一个操作符字节;
	根据操作符的值执行一个动作;
}while(程序未结束)
```
寄存器(用于保存机器的运行状态)
- PC 
Java程序计数器
- optop 
指向操作数栈顶端的指针
- frame 
指向当前执行方法的执行环境的指针
- vars 
指向当前执行方法的局部变量区第一个变量的指针



JVM内部有两种线程 守护线程，如JVM使用过程中的垃圾处理 非守护线程，如main

java命令其实代表着Java SDK的Java虚拟机
```
java xx parm1,parm2
```

##### JVM中的数据类型
> JVM中的boolean Java源码编译成字节码时，会用int或者byte来表示boolean(false-0, tyre-非0整数)
JVM中额外的基本类型 returnAddress 指向一条VM指令的操作码  用于实现finally语句
JVM中的引用类型称为引用 reference 分为 类类型 接口类型 数组类型 null表示无引用
(JVM最基本的数据单位 Word 字)

JVM两种类加载器 启动类加载器 用户自定义加载器

----
##### Runtime Data Area
JVM中Runtime Dae Area中有如下几个数据结构：
1. Stack Java栈
2. Heap Java堆
3. Method Area 方法区
4. PC Register 程序计数器
5. Native Method Area 本地方法区


每个JVM实例都有一个**方法区**以及一个**堆**,所有线程共享
一个新线程被创建时，将得到比它自己的**PC**(寄存器)以及一个**Java栈**



####  Java栈
Java栈中存储着该线程中Java方法调用的状态(非本地方法)
————局部变量被调用时传进来的参数，方法的返回值，运算的中间结果。

Java栈的基本元素是Java栈帧，而Java栈帧组成如下：
1. 局部变量区
2. 操作数栈
3. 帧数据区

一个方法的调用至执行结束，就对应着一个栈帧从虚拟机栈中入栈到出栈的过程。

Java栈的操作：方法执行时压入栈，方法返回或异常时弹出栈。

- 局部变量区
存放编译期可知的各种基本类型，对象引用和returnAddress类。每个方法使用一个固定大小的局部变量集，32位。方法的参数顺序严格固定，局部变量任意。
局部变量区内数据，如果是double型的变量则占有n,n+1两个位置的空间。
byte,short,char被转换成int型。
数据访问通过索引访问。


- 帧数据区
用以支持常量池解析(比如需要使用常量等非局部变量的数据),用以支持正常的方法返回，异常派发机制。

- 运行环境区
包含的信息用来实现动态链接，正常方法的返回，异常和错误的传播

- 操作数栈区
机器指令从操作数栈中获取操作数 iadd指令取栈顶两指令相加





#### 方法区
各线程共享，存储被虚拟机加载的类信息，常量，静态变量。

当VM装载某个类型时，它使用类加载器定位相应的class文件,连接虚拟机提取其中的类型信息，并将这些信息存储到方法区，该类型的类型变量存储在方法区中。方法去区大小不固定，空间不连续，也可被堆垃圾回收。
1. 具体存储的类型信息：
1.1 全限定名，超类，超接口的全限定名
1.2 域的类型(引用类型)
1.3 访问修饰符
2. 常量池，也称为运行时常量池，存储各种字面量(如字符串"123")和符号引用。
3. 字段信息(名，类型，修饰符)
4. 方法信息（名，返回类型，参会类型以及顺序，修饰符）
5. 类变量(静态变量) 
6. 指向类加载器的引用
7. 指向Class实例的引用
8. 方法表


> 符号引用 一个类在编译期不知道所引用类的内存地址，只能用符号引用来表示

#### PC （程序计数器）(Program Counter Register)
一个字长(32位),通过改变计数器的值来选取下一条要执行指令的字节码。线程私有，一个线程拥有一个PC，如果正在执行的是本地方法，PC值为undefined
PC中存储着指向下一条被将被执行的指令，其实指的是线程或者说是具体的某个方法。

#### Java堆
线程共享，存放对象实例(包括数组)。逻辑上连续。

JVM虚拟机没有规定Java对象是如何在堆中表示。但是声明了对象应该包含的基本数据，所属类，超类的实例变量，指向方法区的指针。

因此有如下设计
设计一：
把堆分为句柄池，对象池。句柄池中的条目含有分别指向对象池(实例数据)和方法区的指针。
好处，对象的添加删除比较快。

设计二：
堆不分区，直接包含对象实例数据，对象实例数据中包含一个指向方法区的指针。
减少了一次指针定位的开销，对象的访问比较快。但是添加删除相较慢。

数组在堆中的表示，数组也有一个相关联的Class实例，数组的长度，数据存储在堆中。